{"ast":null,"code":"import ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, DIRECTION, objectIncludes, forceDirection } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n\n/** Append flags */\n\n/** Extract flags */\n\n// see https://github.com/microsoft/TypeScript/issues/6223\n\n/** Provides common masking stuff */\nclass Masked {\n  /** */\n\n  /** */\n\n  /** Transforms value before mask processing */\n\n  /** Transforms each char before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing at the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse string to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  constructor(opts) {\n    this._value = '';\n    this._update({\n      ...Masked.DEFAULTS,\n      ...opts\n    });\n    this._initialized = true;\n  }\n\n  /** Sets and applies new options */\n  updateOptions(opts) {\n    if (!this.optionsIsChanged(opts)) return;\n    this.withValueRefresh(this._update.bind(this, opts));\n  }\n\n  /** Sets new options */\n  _update(opts) {\n    Object.assign(this, opts);\n  }\n\n  /** Mask state */\n  get state() {\n    return {\n      _value: this.value,\n      _rawInputValue: this.rawInputValue\n    };\n  }\n  set state(state) {\n    this._value = state._value;\n  }\n\n  /** Resets value */\n  reset() {\n    this._value = '';\n  }\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    this.resolve(value, {\n      input: true\n    });\n  }\n\n  /** Resolve new value */\n  resolve(value, flags) {\n    if (flags === void 0) {\n      flags = {\n        input: true\n      };\n    }\n    this.reset();\n    this.append(value, flags, '');\n    this.doCommit();\n  }\n  get unmaskedValue() {\n    return this.value;\n  }\n  set unmaskedValue(value) {\n    this.resolve(value, {});\n  }\n  get typedValue() {\n    return this.parse ? this.parse(this.value, this) : this.unmaskedValue;\n  }\n  set typedValue(value) {\n    if (this.format) {\n      this.value = this.format(value, this);\n    } else {\n      this.unmaskedValue = String(value);\n    }\n  }\n\n  /** Value that includes raw user input */\n  get rawInputValue() {\n    return this.extractInput(0, this.displayValue.length, {\n      raw: true\n    });\n  }\n  set rawInputValue(value) {\n    this.resolve(value, {\n      raw: true\n    });\n  }\n  get displayValue() {\n    return this.value;\n  }\n  get isComplete() {\n    return true;\n  }\n  get isFilled() {\n    return this.isComplete;\n  }\n\n  /** Finds nearest input position in direction */\n  nearestInputPos(cursorPos, direction) {\n    return cursorPos;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    return Math.min(this.displayValue.length, toPos - fromPos);\n  }\n\n  /** Extracts value in range considering flags */\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    return this.displayValue.slice(fromPos, toPos);\n  }\n\n  /** Extracts tail in range */\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n  }\n\n  /** Appends tail */\n  appendTail(tail) {\n    if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n    return tail.appendTo(this);\n  }\n\n  /** Appends char */\n  _appendCharRaw(ch, flags) {\n    if (!ch) return new ChangeDetails();\n    this._value += ch;\n    return new ChangeDetails({\n      inserted: ch,\n      rawInserted: ch\n    });\n  }\n\n  /** Appends char */\n  _appendChar(ch, flags, checkTail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const consistentState = this.state;\n    let details;\n    [ch, details] = this.doPrepareChar(ch, flags);\n    if (ch) {\n      details = details.aggregate(this._appendCharRaw(ch, flags));\n\n      // TODO handle `skip`?\n\n      // try `autofix` lookahead\n      if (!details.rawInserted && this.autofix === 'pad') {\n        const noFixState = this.state;\n        this.state = consistentState;\n        let fixDetails = this.pad(flags);\n        const chDetails = this._appendCharRaw(ch, flags);\n        fixDetails = fixDetails.aggregate(chDetails);\n\n        // if fix was applied or\n        // if details are equal use skip restoring state optimization\n        if (chDetails.rawInserted || fixDetails.equals(details)) {\n          details = fixDetails;\n        } else {\n          this.state = noFixState;\n        }\n      }\n    }\n    if (details.inserted) {\n      let consistentTail;\n      let appended = this.doValidate(flags) !== false;\n      if (appended && checkTail != null) {\n        // validation ok, check tail\n        const beforeTailState = this.state;\n        if (this.overwrite === true) {\n          consistentTail = checkTail.state;\n          for (let i = 0; i < details.rawInserted.length; ++i) {\n            checkTail.unshift(this.displayValue.length - details.tailShift);\n          }\n        }\n        let tailDetails = this.appendTail(checkTail);\n        appended = tailDetails.rawInserted.length === checkTail.toString().length;\n\n        // not ok, try shift\n        if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n          this.state = beforeTailState;\n          consistentTail = checkTail.state;\n          for (let i = 0; i < details.rawInserted.length; ++i) {\n            checkTail.shift();\n          }\n          tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted.length === checkTail.toString().length;\n        }\n\n        // if ok, rollback state after tail\n        if (appended && tailDetails.inserted) this.state = beforeTailState;\n      }\n\n      // revert all if something went wrong\n      if (!appended) {\n        details = new ChangeDetails();\n        this.state = consistentState;\n        if (checkTail && consistentTail) checkTail.state = consistentTail;\n      }\n    }\n    return details;\n  }\n\n  /** Appends optional placeholder at the end */\n  _appendPlaceholder() {\n    return new ChangeDetails();\n  }\n\n  /** Appends optional eager placeholder at the end */\n  _appendEager() {\n    return new ChangeDetails();\n  }\n\n  /** Appends symbols considering flags */\n  append(str, flags, tail) {\n    if (!isString(str)) throw new Error('value should be string');\n    const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n    if (flags != null && flags.tail) flags._beforeTailState = this.state;\n    let details;\n    [str, details] = this.doPrepare(str, flags);\n    for (let ci = 0; ci < str.length; ++ci) {\n      const d = this._appendChar(str[ci], flags, checkTail);\n      if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n      details.aggregate(d);\n    }\n    if ((this.eager === true || this.eager === 'append') && flags != null && flags.input && str) {\n      details.aggregate(this._appendEager());\n    }\n\n    // append tail but aggregate only tailShift\n    if (checkTail != null) {\n      details.tailShift += this.appendTail(checkTail).tailShift;\n      // TODO it's a good idea to clear state after appending ends\n      // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n      // this._resetBeforeTailState();\n    }\n    return details;\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    this._value = this.displayValue.slice(0, fromPos) + this.displayValue.slice(toPos);\n    return new ChangeDetails();\n  }\n\n  /** Calls function and reapplies current value */\n  withValueRefresh(fn) {\n    if (this._refreshing || !this._initialized) return fn();\n    this._refreshing = true;\n    const rawInput = this.rawInputValue;\n    const value = this.value;\n    const ret = fn();\n    this.rawInputValue = rawInput;\n    // append lost trailing chars at the end\n    if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n      this.append(value.slice(this.displayValue.length), {}, '');\n      this.doCommit();\n    }\n    delete this._refreshing;\n    return ret;\n  }\n  runIsolated(fn) {\n    if (this._isolated || !this._initialized) return fn(this);\n    this._isolated = true;\n    const state = this.state;\n    const ret = fn(this);\n    this.state = state;\n    delete this._isolated;\n    return ret;\n  }\n  doSkipInvalid(ch, flags, checkTail) {\n    return Boolean(this.skipInvalid);\n  }\n\n  /** Prepares string before mask processing */\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    return ChangeDetails.normalize(this.prepare ? this.prepare(str, this, flags) : str);\n  }\n\n  /** Prepares each char before mask processing */\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    return ChangeDetails.normalize(this.prepareChar ? this.prepareChar(str, this, flags) : str);\n  }\n\n  /** Validates if value is acceptable */\n  doValidate(flags) {\n    return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n  }\n\n  /** Does additional processing at the end of editing */\n  doCommit() {\n    if (this.commit) this.commit(this.value, this);\n  }\n  splice(start, deleteCount, inserted, removeDirection, flags) {\n    if (inserted === void 0) {\n      inserted = '';\n    }\n    if (removeDirection === void 0) {\n      removeDirection = DIRECTION.NONE;\n    }\n    if (flags === void 0) {\n      flags = {\n        input: true\n      };\n    }\n    const tailPos = start + deleteCount;\n    const tail = this.extractTail(tailPos);\n    const eagerRemove = this.eager === true || this.eager === 'remove';\n    let oldRawValue;\n    if (eagerRemove) {\n      removeDirection = forceDirection(removeDirection);\n      oldRawValue = this.extractInput(0, tailPos, {\n        raw: true\n      });\n    }\n    let startChangePos = start;\n    const details = new ChangeDetails();\n\n    // if it is just deletion without insertion\n    if (removeDirection !== DIRECTION.NONE) {\n      startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);\n\n      // adjust tailShift if start was aligned\n      details.tailShift = startChangePos - start;\n    }\n    details.aggregate(this.remove(startChangePos));\n    if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n      if (removeDirection === DIRECTION.FORCE_LEFT) {\n        let valLength;\n        while (oldRawValue === this.rawInputValue && (valLength = this.displayValue.length)) {\n          details.aggregate(new ChangeDetails({\n            tailShift: -1\n          })).aggregate(this.remove(valLength - 1));\n        }\n      } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n        tail.unshift();\n      }\n    }\n    return details.aggregate(this.append(inserted, flags, tail));\n  }\n  maskEquals(mask) {\n    return this.mask === mask;\n  }\n  optionsIsChanged(opts) {\n    return !objectIncludes(this, opts);\n  }\n  typedValueEquals(value) {\n    const tval = this.typedValue;\n    return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || (this.format ? this.format(value, this) === this.format(this.typedValue, this) : false);\n  }\n  pad(flags) {\n    return new ChangeDetails();\n  }\n}\nMasked.DEFAULTS = {\n  skipInvalid: true\n};\nMasked.EMPTY_VALUES = [undefined, null, ''];\nIMask.Masked = Masked;\nexport { Masked as default };","map":{"version":3,"names":["ChangeDetails","ContinuousTailDetails","isString","DIRECTION","objectIncludes","forceDirection","IMask","Masked","constructor","opts","_value","_update","DEFAULTS","_initialized","updateOptions","optionsIsChanged","withValueRefresh","bind","Object","assign","state","value","_rawInputValue","rawInputValue","reset","resolve","input","flags","append","doCommit","unmaskedValue","typedValue","parse","format","String","extractInput","displayValue","length","raw","isComplete","isFilled","nearestInputPos","cursorPos","direction","totalInputPositions","fromPos","toPos","Math","min","slice","extractTail","appendTail","tail","appendTo","_appendCharRaw","ch","inserted","rawInserted","_appendChar","checkTail","consistentState","details","doPrepareChar","aggregate","autofix","noFixState","fixDetails","pad","chDetails","equals","consistentTail","appended","doValidate","beforeTailState","overwrite","i","unshift","tailShift","tailDetails","toString","shift","_appendPlaceholder","_appendEager","str","Error","_beforeTailState","doPrepare","ci","d","doSkipInvalid","eager","remove","fn","_refreshing","rawInput","ret","indexOf","runIsolated","_isolated","Boolean","skipInvalid","normalize","prepare","prepareChar","validate","parent","commit","splice","start","deleteCount","removeDirection","NONE","tailPos","eagerRemove","oldRawValue","startChangePos","FORCE_LEFT","valLength","FORCE_RIGHT","maskEquals","mask","typedValueEquals","tval","EMPTY_VALUES","includes","undefined","default"],"sources":["F:/web/ЗАКАЗЫ/АЙФОРДЖИ/project-pattern-test/project-root/frontend/node_modules/imask/esm/masked/base.js"],"sourcesContent":["import ChangeDetails from '../core/change-details.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport { isString, DIRECTION, objectIncludes, forceDirection } from '../core/utils.js';\nimport IMask from '../core/holder.js';\n\n/** Append flags */\n\n/** Extract flags */\n\n// see https://github.com/microsoft/TypeScript/issues/6223\n\n/** Provides common masking stuff */\nclass Masked {\n  /** */\n\n  /** */\n\n  /** Transforms value before mask processing */\n\n  /** Transforms each char before mask processing */\n\n  /** Validates if value is acceptable */\n\n  /** Does additional processing at the end of editing */\n\n  /** Format typed value to string */\n\n  /** Parse string to get typed value */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  constructor(opts) {\n    this._value = '';\n    this._update({\n      ...Masked.DEFAULTS,\n      ...opts\n    });\n    this._initialized = true;\n  }\n\n  /** Sets and applies new options */\n  updateOptions(opts) {\n    if (!this.optionsIsChanged(opts)) return;\n    this.withValueRefresh(this._update.bind(this, opts));\n  }\n\n  /** Sets new options */\n  _update(opts) {\n    Object.assign(this, opts);\n  }\n\n  /** Mask state */\n  get state() {\n    return {\n      _value: this.value,\n      _rawInputValue: this.rawInputValue\n    };\n  }\n  set state(state) {\n    this._value = state._value;\n  }\n\n  /** Resets value */\n  reset() {\n    this._value = '';\n  }\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    this.resolve(value, {\n      input: true\n    });\n  }\n\n  /** Resolve new value */\n  resolve(value, flags) {\n    if (flags === void 0) {\n      flags = {\n        input: true\n      };\n    }\n    this.reset();\n    this.append(value, flags, '');\n    this.doCommit();\n  }\n  get unmaskedValue() {\n    return this.value;\n  }\n  set unmaskedValue(value) {\n    this.resolve(value, {});\n  }\n  get typedValue() {\n    return this.parse ? this.parse(this.value, this) : this.unmaskedValue;\n  }\n  set typedValue(value) {\n    if (this.format) {\n      this.value = this.format(value, this);\n    } else {\n      this.unmaskedValue = String(value);\n    }\n  }\n\n  /** Value that includes raw user input */\n  get rawInputValue() {\n    return this.extractInput(0, this.displayValue.length, {\n      raw: true\n    });\n  }\n  set rawInputValue(value) {\n    this.resolve(value, {\n      raw: true\n    });\n  }\n  get displayValue() {\n    return this.value;\n  }\n  get isComplete() {\n    return true;\n  }\n  get isFilled() {\n    return this.isComplete;\n  }\n\n  /** Finds nearest input position in direction */\n  nearestInputPos(cursorPos, direction) {\n    return cursorPos;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    return Math.min(this.displayValue.length, toPos - fromPos);\n  }\n\n  /** Extracts value in range considering flags */\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    return this.displayValue.slice(fromPos, toPos);\n  }\n\n  /** Extracts tail in range */\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);\n  }\n\n  /** Appends tail */\n  appendTail(tail) {\n    if (isString(tail)) tail = new ContinuousTailDetails(String(tail));\n    return tail.appendTo(this);\n  }\n\n  /** Appends char */\n  _appendCharRaw(ch, flags) {\n    if (!ch) return new ChangeDetails();\n    this._value += ch;\n    return new ChangeDetails({\n      inserted: ch,\n      rawInserted: ch\n    });\n  }\n\n  /** Appends char */\n  _appendChar(ch, flags, checkTail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const consistentState = this.state;\n    let details;\n    [ch, details] = this.doPrepareChar(ch, flags);\n    if (ch) {\n      details = details.aggregate(this._appendCharRaw(ch, flags));\n\n      // TODO handle `skip`?\n\n      // try `autofix` lookahead\n      if (!details.rawInserted && this.autofix === 'pad') {\n        const noFixState = this.state;\n        this.state = consistentState;\n        let fixDetails = this.pad(flags);\n        const chDetails = this._appendCharRaw(ch, flags);\n        fixDetails = fixDetails.aggregate(chDetails);\n\n        // if fix was applied or\n        // if details are equal use skip restoring state optimization\n        if (chDetails.rawInserted || fixDetails.equals(details)) {\n          details = fixDetails;\n        } else {\n          this.state = noFixState;\n        }\n      }\n    }\n    if (details.inserted) {\n      let consistentTail;\n      let appended = this.doValidate(flags) !== false;\n      if (appended && checkTail != null) {\n        // validation ok, check tail\n        const beforeTailState = this.state;\n        if (this.overwrite === true) {\n          consistentTail = checkTail.state;\n          for (let i = 0; i < details.rawInserted.length; ++i) {\n            checkTail.unshift(this.displayValue.length - details.tailShift);\n          }\n        }\n        let tailDetails = this.appendTail(checkTail);\n        appended = tailDetails.rawInserted.length === checkTail.toString().length;\n\n        // not ok, try shift\n        if (!(appended && tailDetails.inserted) && this.overwrite === 'shift') {\n          this.state = beforeTailState;\n          consistentTail = checkTail.state;\n          for (let i = 0; i < details.rawInserted.length; ++i) {\n            checkTail.shift();\n          }\n          tailDetails = this.appendTail(checkTail);\n          appended = tailDetails.rawInserted.length === checkTail.toString().length;\n        }\n\n        // if ok, rollback state after tail\n        if (appended && tailDetails.inserted) this.state = beforeTailState;\n      }\n\n      // revert all if something went wrong\n      if (!appended) {\n        details = new ChangeDetails();\n        this.state = consistentState;\n        if (checkTail && consistentTail) checkTail.state = consistentTail;\n      }\n    }\n    return details;\n  }\n\n  /** Appends optional placeholder at the end */\n  _appendPlaceholder() {\n    return new ChangeDetails();\n  }\n\n  /** Appends optional eager placeholder at the end */\n  _appendEager() {\n    return new ChangeDetails();\n  }\n\n  /** Appends symbols considering flags */\n  append(str, flags, tail) {\n    if (!isString(str)) throw new Error('value should be string');\n    const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;\n    if (flags != null && flags.tail) flags._beforeTailState = this.state;\n    let details;\n    [str, details] = this.doPrepare(str, flags);\n    for (let ci = 0; ci < str.length; ++ci) {\n      const d = this._appendChar(str[ci], flags, checkTail);\n      if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;\n      details.aggregate(d);\n    }\n    if ((this.eager === true || this.eager === 'append') && flags != null && flags.input && str) {\n      details.aggregate(this._appendEager());\n    }\n\n    // append tail but aggregate only tailShift\n    if (checkTail != null) {\n      details.tailShift += this.appendTail(checkTail).tailShift;\n      // TODO it's a good idea to clear state after appending ends\n      // but it causes bugs when one append calls another (when dynamic dispatch set rawInputValue)\n      // this._resetBeforeTailState();\n    }\n    return details;\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    this._value = this.displayValue.slice(0, fromPos) + this.displayValue.slice(toPos);\n    return new ChangeDetails();\n  }\n\n  /** Calls function and reapplies current value */\n  withValueRefresh(fn) {\n    if (this._refreshing || !this._initialized) return fn();\n    this._refreshing = true;\n    const rawInput = this.rawInputValue;\n    const value = this.value;\n    const ret = fn();\n    this.rawInputValue = rawInput;\n    // append lost trailing chars at the end\n    if (this.value && this.value !== value && value.indexOf(this.value) === 0) {\n      this.append(value.slice(this.displayValue.length), {}, '');\n      this.doCommit();\n    }\n    delete this._refreshing;\n    return ret;\n  }\n  runIsolated(fn) {\n    if (this._isolated || !this._initialized) return fn(this);\n    this._isolated = true;\n    const state = this.state;\n    const ret = fn(this);\n    this.state = state;\n    delete this._isolated;\n    return ret;\n  }\n  doSkipInvalid(ch, flags, checkTail) {\n    return Boolean(this.skipInvalid);\n  }\n\n  /** Prepares string before mask processing */\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    return ChangeDetails.normalize(this.prepare ? this.prepare(str, this, flags) : str);\n  }\n\n  /** Prepares each char before mask processing */\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    return ChangeDetails.normalize(this.prepareChar ? this.prepareChar(str, this, flags) : str);\n  }\n\n  /** Validates if value is acceptable */\n  doValidate(flags) {\n    return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));\n  }\n\n  /** Does additional processing at the end of editing */\n  doCommit() {\n    if (this.commit) this.commit(this.value, this);\n  }\n  splice(start, deleteCount, inserted, removeDirection, flags) {\n    if (inserted === void 0) {\n      inserted = '';\n    }\n    if (removeDirection === void 0) {\n      removeDirection = DIRECTION.NONE;\n    }\n    if (flags === void 0) {\n      flags = {\n        input: true\n      };\n    }\n    const tailPos = start + deleteCount;\n    const tail = this.extractTail(tailPos);\n    const eagerRemove = this.eager === true || this.eager === 'remove';\n    let oldRawValue;\n    if (eagerRemove) {\n      removeDirection = forceDirection(removeDirection);\n      oldRawValue = this.extractInput(0, tailPos, {\n        raw: true\n      });\n    }\n    let startChangePos = start;\n    const details = new ChangeDetails();\n\n    // if it is just deletion without insertion\n    if (removeDirection !== DIRECTION.NONE) {\n      startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);\n\n      // adjust tailShift if start was aligned\n      details.tailShift = startChangePos - start;\n    }\n    details.aggregate(this.remove(startChangePos));\n    if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) {\n      if (removeDirection === DIRECTION.FORCE_LEFT) {\n        let valLength;\n        while (oldRawValue === this.rawInputValue && (valLength = this.displayValue.length)) {\n          details.aggregate(new ChangeDetails({\n            tailShift: -1\n          })).aggregate(this.remove(valLength - 1));\n        }\n      } else if (removeDirection === DIRECTION.FORCE_RIGHT) {\n        tail.unshift();\n      }\n    }\n    return details.aggregate(this.append(inserted, flags, tail));\n  }\n  maskEquals(mask) {\n    return this.mask === mask;\n  }\n  optionsIsChanged(opts) {\n    return !objectIncludes(this, opts);\n  }\n  typedValueEquals(value) {\n    const tval = this.typedValue;\n    return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || (this.format ? this.format(value, this) === this.format(this.typedValue, this) : false);\n  }\n  pad(flags) {\n    return new ChangeDetails();\n  }\n}\nMasked.DEFAULTS = {\n  skipInvalid: true\n};\nMasked.EMPTY_VALUES = [undefined, null, ''];\nIMask.Masked = Masked;\n\nexport { Masked as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}