{"ast":null,"code":"import ChangeDetails from '../core/change-details.js';\nimport IMask from '../core/holder.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport MaskedPattern from './pattern.js';\nimport '../core/utils.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/input-definition.js';\nimport './regexp.js';\n\n/** Pattern mask */\nclass RepeatBlock extends MaskedPattern {\n  get repeatFrom() {\n    var _ref;\n    return (_ref = Array.isArray(this.repeat) ? this.repeat[0] : this.repeat === Infinity ? 0 : this.repeat) != null ? _ref : 0;\n  }\n  get repeatTo() {\n    var _ref2;\n    return (_ref2 = Array.isArray(this.repeat) ? this.repeat[1] : this.repeat) != null ? _ref2 : Infinity;\n  }\n  constructor(opts) {\n    super(opts);\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    var _ref3, _ref4, _this$_blocks;\n    const {\n      repeat,\n      ...blockOpts\n    } = normalizeOpts(opts); // TODO type\n    this._blockOpts = Object.assign({}, this._blockOpts, blockOpts);\n    const block = createMask(this._blockOpts);\n    this.repeat = (_ref3 = (_ref4 = repeat != null ? repeat : block.repeat) != null ? _ref4 : this.repeat) != null ? _ref3 : Infinity; // TODO type\n\n    super._update({\n      mask: 'm'.repeat(Math.max(this.repeatTo === Infinity && ((_this$_blocks = this._blocks) == null ? void 0 : _this$_blocks.length) || 0, this.repeatFrom)),\n      blocks: {\n        m: block\n      },\n      eager: block.eager,\n      overwrite: block.overwrite,\n      skipInvalid: block.skipInvalid,\n      lazy: block.lazy,\n      placeholderChar: block.placeholderChar,\n      displayChar: block.displayChar\n    });\n  }\n  _allocateBlock(bi) {\n    if (bi < this._blocks.length) return this._blocks[bi];\n    if (this.repeatTo === Infinity || this._blocks.length < this.repeatTo) {\n      this._blocks.push(createMask(this._blockOpts));\n      this.mask += 'm';\n      return this._blocks[this._blocks.length - 1];\n    }\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const details = new ChangeDetails();\n    for (let bi = (_this$_mapPosToBlock$ = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index) != null ? _this$_mapPosToBlock$ : Math.max(this._blocks.length - 1, 0), block, allocated;\n    // try to get a block or\n    // try to allocate a new block if not allocated already\n    block = (_this$_blocks$bi = this._blocks[bi]) != null ? _this$_blocks$bi : allocated = !allocated && this._allocateBlock(bi); ++bi) {\n      var _this$_mapPosToBlock$, _this$_mapPosToBlock, _this$_blocks$bi, _flags$_beforeTailSta;\n      const blockDetails = block._appendChar(ch, {\n        ...flags,\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null || (_flags$_beforeTailSta = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta[bi]\n      });\n      if (blockDetails.skip && allocated) {\n        // remove the last allocated block and break\n        this._blocks.pop();\n        this.mask = this.mask.slice(1);\n        break;\n      }\n      details.aggregate(blockDetails);\n      if (blockDetails.consumed) break; // go next char\n    }\n    return details;\n  }\n  _trimEmptyTail(fromPos, toPos) {\n    var _this$_mapPosToBlock2, _this$_mapPosToBlock3;\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    const firstBlockIndex = Math.max(((_this$_mapPosToBlock2 = this._mapPosToBlock(fromPos)) == null ? void 0 : _this$_mapPosToBlock2.index) || 0, this.repeatFrom, 0);\n    let lastBlockIndex;\n    if (toPos != null) lastBlockIndex = (_this$_mapPosToBlock3 = this._mapPosToBlock(toPos)) == null ? void 0 : _this$_mapPosToBlock3.index;\n    if (lastBlockIndex == null) lastBlockIndex = this._blocks.length - 1;\n    let removeCount = 0;\n    for (let blockIndex = lastBlockIndex; firstBlockIndex <= blockIndex; --blockIndex, ++removeCount) {\n      if (this._blocks[blockIndex].unmaskedValue) break;\n    }\n    if (removeCount) {\n      this._blocks.splice(lastBlockIndex - removeCount + 1, removeCount);\n      this.mask = this.mask.slice(removeCount);\n    }\n  }\n  reset() {\n    super.reset();\n    this._trimEmptyTail();\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const removeDetails = super.remove(fromPos, toPos);\n    this._trimEmptyTail(fromPos, toPos);\n    return removeDetails;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos == null && this.repeatTo === Infinity) return Infinity;\n    return super.totalInputPositions(fromPos, toPos);\n  }\n  get state() {\n    return super.state;\n  }\n  set state(state) {\n    this._blocks.length = state._blocks.length;\n    this.mask = this.mask.slice(0, this._blocks.length);\n    super.state = state;\n  }\n}\nIMask.RepeatBlock = RepeatBlock;\nexport { RepeatBlock as default };","map":{"version":3,"names":["ChangeDetails","IMask","createMask","normalizeOpts","MaskedPattern","RepeatBlock","repeatFrom","_ref","Array","isArray","repeat","Infinity","repeatTo","_ref2","constructor","opts","updateOptions","_update","_ref3","_ref4","_this$_blocks","blockOpts","_blockOpts","Object","assign","block","mask","Math","max","_blocks","length","blocks","m","eager","overwrite","skipInvalid","lazy","placeholderChar","displayChar","_allocateBlock","bi","push","_appendCharRaw","ch","flags","details","_this$_mapPosToBlock$","_this$_mapPosToBlock","_mapPosToBlock","displayValue","index","allocated","_this$_blocks$bi","_flags$_beforeTailSta","blockDetails","_appendChar","_beforeTailState","skip","pop","slice","aggregate","consumed","_trimEmptyTail","fromPos","toPos","_this$_mapPosToBlock2","_this$_mapPosToBlock3","firstBlockIndex","lastBlockIndex","removeCount","blockIndex","unmaskedValue","splice","reset","remove","removeDetails","totalInputPositions","state","default"],"sources":["F:/web/ЗАКАЗЫ/АЙФОРДЖИ/project-pattern-test/project-root/frontend/node_modules/imask/esm/masked/repeat.js"],"sourcesContent":["import ChangeDetails from '../core/change-details.js';\nimport IMask from '../core/holder.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport MaskedPattern from './pattern.js';\nimport '../core/utils.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/input-definition.js';\nimport './regexp.js';\n\n/** Pattern mask */\nclass RepeatBlock extends MaskedPattern {\n  get repeatFrom() {\n    var _ref;\n    return (_ref = Array.isArray(this.repeat) ? this.repeat[0] : this.repeat === Infinity ? 0 : this.repeat) != null ? _ref : 0;\n  }\n  get repeatTo() {\n    var _ref2;\n    return (_ref2 = Array.isArray(this.repeat) ? this.repeat[1] : this.repeat) != null ? _ref2 : Infinity;\n  }\n  constructor(opts) {\n    super(opts);\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    var _ref3, _ref4, _this$_blocks;\n    const {\n      repeat,\n      ...blockOpts\n    } = normalizeOpts(opts); // TODO type\n    this._blockOpts = Object.assign({}, this._blockOpts, blockOpts);\n    const block = createMask(this._blockOpts);\n    this.repeat = (_ref3 = (_ref4 = repeat != null ? repeat : block.repeat) != null ? _ref4 : this.repeat) != null ? _ref3 : Infinity; // TODO type\n\n    super._update({\n      mask: 'm'.repeat(Math.max(this.repeatTo === Infinity && ((_this$_blocks = this._blocks) == null ? void 0 : _this$_blocks.length) || 0, this.repeatFrom)),\n      blocks: {\n        m: block\n      },\n      eager: block.eager,\n      overwrite: block.overwrite,\n      skipInvalid: block.skipInvalid,\n      lazy: block.lazy,\n      placeholderChar: block.placeholderChar,\n      displayChar: block.displayChar\n    });\n  }\n  _allocateBlock(bi) {\n    if (bi < this._blocks.length) return this._blocks[bi];\n    if (this.repeatTo === Infinity || this._blocks.length < this.repeatTo) {\n      this._blocks.push(createMask(this._blockOpts));\n      this.mask += 'm';\n      return this._blocks[this._blocks.length - 1];\n    }\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const details = new ChangeDetails();\n    for (let bi = (_this$_mapPosToBlock$ = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index) != null ? _this$_mapPosToBlock$ : Math.max(this._blocks.length - 1, 0), block, allocated;\n    // try to get a block or\n    // try to allocate a new block if not allocated already\n    block = (_this$_blocks$bi = this._blocks[bi]) != null ? _this$_blocks$bi : allocated = !allocated && this._allocateBlock(bi); ++bi) {\n      var _this$_mapPosToBlock$, _this$_mapPosToBlock, _this$_blocks$bi, _flags$_beforeTailSta;\n      const blockDetails = block._appendChar(ch, {\n        ...flags,\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null || (_flags$_beforeTailSta = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta[bi]\n      });\n      if (blockDetails.skip && allocated) {\n        // remove the last allocated block and break\n        this._blocks.pop();\n        this.mask = this.mask.slice(1);\n        break;\n      }\n      details.aggregate(blockDetails);\n      if (blockDetails.consumed) break; // go next char\n    }\n    return details;\n  }\n  _trimEmptyTail(fromPos, toPos) {\n    var _this$_mapPosToBlock2, _this$_mapPosToBlock3;\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    const firstBlockIndex = Math.max(((_this$_mapPosToBlock2 = this._mapPosToBlock(fromPos)) == null ? void 0 : _this$_mapPosToBlock2.index) || 0, this.repeatFrom, 0);\n    let lastBlockIndex;\n    if (toPos != null) lastBlockIndex = (_this$_mapPosToBlock3 = this._mapPosToBlock(toPos)) == null ? void 0 : _this$_mapPosToBlock3.index;\n    if (lastBlockIndex == null) lastBlockIndex = this._blocks.length - 1;\n    let removeCount = 0;\n    for (let blockIndex = lastBlockIndex; firstBlockIndex <= blockIndex; --blockIndex, ++removeCount) {\n      if (this._blocks[blockIndex].unmaskedValue) break;\n    }\n    if (removeCount) {\n      this._blocks.splice(lastBlockIndex - removeCount + 1, removeCount);\n      this.mask = this.mask.slice(removeCount);\n    }\n  }\n  reset() {\n    super.reset();\n    this._trimEmptyTail();\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const removeDetails = super.remove(fromPos, toPos);\n    this._trimEmptyTail(fromPos, toPos);\n    return removeDetails;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos == null && this.repeatTo === Infinity) return Infinity;\n    return super.totalInputPositions(fromPos, toPos);\n  }\n  get state() {\n    return super.state;\n  }\n  set state(state) {\n    this._blocks.length = state._blocks.length;\n    this.mask = this.mask.slice(0, this._blocks.length);\n    super.state = state;\n  }\n}\nIMask.RepeatBlock = RepeatBlock;\n\nexport { RepeatBlock as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}