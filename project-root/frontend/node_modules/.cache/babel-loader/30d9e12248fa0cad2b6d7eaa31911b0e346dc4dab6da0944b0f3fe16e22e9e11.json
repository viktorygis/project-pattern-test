{"ast":null,"code":"import ChangeDetails from '../core/change-details.js';\nimport IMask from '../core/holder.js';\nimport MaskedPattern from './pattern.js';\nimport '../core/utils.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './factory.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/input-definition.js';\nimport './regexp.js';\n\n/** Pattern which accepts ranges */\nclass MaskedRange extends MaskedPattern {\n  /**\n    Optionally sets max length of pattern.\n    Used when pattern length is longer then `to` param length. Pads zeros at start in this case.\n  */\n\n  /** Min bound */\n\n  /** Max bound */\n\n  get _matchFrom() {\n    return this.maxLength - String(this.from).length;\n  }\n  constructor(opts) {\n    super(opts); // mask will be created in _update\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    const {\n      to = this.to || 0,\n      from = this.from || 0,\n      maxLength = this.maxLength || 0,\n      autofix = this.autofix,\n      ...patternOpts\n    } = opts;\n    this.to = to;\n    this.from = from;\n    this.maxLength = Math.max(String(to).length, maxLength);\n    this.autofix = autofix;\n    const fromStr = String(this.from).padStart(this.maxLength, '0');\n    const toStr = String(this.to).padStart(this.maxLength, '0');\n    let sameCharsCount = 0;\n    while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) ++sameCharsCount;\n    patternOpts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\\\0') + '0'.repeat(this.maxLength - sameCharsCount);\n    super._update(patternOpts);\n  }\n  get isComplete() {\n    return super.isComplete && Boolean(this.value);\n  }\n  boundaries(str) {\n    let minstr = '';\n    let maxstr = '';\n    const [, placeholder, num] = str.match(/^(\\D*)(\\d*)(\\D*)/) || [];\n    if (num) {\n      minstr = '0'.repeat(placeholder.length) + num;\n      maxstr = '9'.repeat(placeholder.length) + num;\n    }\n    minstr = minstr.padEnd(this.maxLength, '0');\n    maxstr = maxstr.padEnd(this.maxLength, '9');\n    return [minstr, maxstr];\n  }\n  doPrepareChar(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let details;\n    [ch, details] = super.doPrepareChar(ch.replace(/\\D/g, ''), flags);\n    if (!ch) details.skip = !this.isComplete;\n    return [ch, details];\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (!this.autofix || this.value.length + 1 > this.maxLength) return super._appendCharRaw(ch, flags);\n    const fromStr = String(this.from).padStart(this.maxLength, '0');\n    const toStr = String(this.to).padStart(this.maxLength, '0');\n    const [minstr, maxstr] = this.boundaries(this.value + ch);\n    if (Number(maxstr) < this.from) return super._appendCharRaw(fromStr[this.value.length], flags);\n    if (Number(minstr) > this.to) {\n      if (!flags.tail && this.autofix === 'pad' && this.value.length + 1 < this.maxLength) {\n        return super._appendCharRaw(fromStr[this.value.length], flags).aggregate(this._appendCharRaw(ch, flags));\n      }\n      return super._appendCharRaw(toStr[this.value.length], flags);\n    }\n    return super._appendCharRaw(ch, flags);\n  }\n  doValidate(flags) {\n    const str = this.value;\n    const firstNonZero = str.search(/[^0]/);\n    if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\n    const [minstr, maxstr] = this.boundaries(str);\n    return this.from <= Number(maxstr) && Number(minstr) <= this.to && super.doValidate(flags);\n  }\n  pad(flags) {\n    const details = new ChangeDetails();\n    if (this.value.length === this.maxLength) return details;\n    const value = this.value;\n    const padLength = this.maxLength - this.value.length;\n    if (padLength) {\n      this.reset();\n      for (let i = 0; i < padLength; ++i) {\n        details.aggregate(super._appendCharRaw('0', flags));\n      }\n\n      // append tail\n      value.split('').forEach(ch => this._appendCharRaw(ch));\n    }\n    return details;\n  }\n}\nIMask.MaskedRange = MaskedRange;\nexport { MaskedRange as default };","map":{"version":3,"names":["ChangeDetails","IMask","MaskedPattern","MaskedRange","_matchFrom","maxLength","String","from","length","constructor","opts","updateOptions","_update","to","autofix","patternOpts","Math","max","fromStr","padStart","toStr","sameCharsCount","mask","slice","replace","repeat","isComplete","Boolean","value","boundaries","str","minstr","maxstr","placeholder","num","match","padEnd","doPrepareChar","ch","flags","details","skip","_appendCharRaw","Number","tail","aggregate","doValidate","firstNonZero","search","pad","padLength","reset","i","split","forEach","default"],"sources":["F:/web/ЗАКАЗЫ/АЙФОРДЖИ/project-pattern-test/project-root/frontend/node_modules/imask/esm/masked/range.js"],"sourcesContent":["import ChangeDetails from '../core/change-details.js';\nimport IMask from '../core/holder.js';\nimport MaskedPattern from './pattern.js';\nimport '../core/utils.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './factory.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/input-definition.js';\nimport './regexp.js';\n\n/** Pattern which accepts ranges */\nclass MaskedRange extends MaskedPattern {\n  /**\n    Optionally sets max length of pattern.\n    Used when pattern length is longer then `to` param length. Pads zeros at start in this case.\n  */\n\n  /** Min bound */\n\n  /** Max bound */\n\n  get _matchFrom() {\n    return this.maxLength - String(this.from).length;\n  }\n  constructor(opts) {\n    super(opts); // mask will be created in _update\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    const {\n      to = this.to || 0,\n      from = this.from || 0,\n      maxLength = this.maxLength || 0,\n      autofix = this.autofix,\n      ...patternOpts\n    } = opts;\n    this.to = to;\n    this.from = from;\n    this.maxLength = Math.max(String(to).length, maxLength);\n    this.autofix = autofix;\n    const fromStr = String(this.from).padStart(this.maxLength, '0');\n    const toStr = String(this.to).padStart(this.maxLength, '0');\n    let sameCharsCount = 0;\n    while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) ++sameCharsCount;\n    patternOpts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\\\0') + '0'.repeat(this.maxLength - sameCharsCount);\n    super._update(patternOpts);\n  }\n  get isComplete() {\n    return super.isComplete && Boolean(this.value);\n  }\n  boundaries(str) {\n    let minstr = '';\n    let maxstr = '';\n    const [, placeholder, num] = str.match(/^(\\D*)(\\d*)(\\D*)/) || [];\n    if (num) {\n      minstr = '0'.repeat(placeholder.length) + num;\n      maxstr = '9'.repeat(placeholder.length) + num;\n    }\n    minstr = minstr.padEnd(this.maxLength, '0');\n    maxstr = maxstr.padEnd(this.maxLength, '9');\n    return [minstr, maxstr];\n  }\n  doPrepareChar(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let details;\n    [ch, details] = super.doPrepareChar(ch.replace(/\\D/g, ''), flags);\n    if (!ch) details.skip = !this.isComplete;\n    return [ch, details];\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (!this.autofix || this.value.length + 1 > this.maxLength) return super._appendCharRaw(ch, flags);\n    const fromStr = String(this.from).padStart(this.maxLength, '0');\n    const toStr = String(this.to).padStart(this.maxLength, '0');\n    const [minstr, maxstr] = this.boundaries(this.value + ch);\n    if (Number(maxstr) < this.from) return super._appendCharRaw(fromStr[this.value.length], flags);\n    if (Number(minstr) > this.to) {\n      if (!flags.tail && this.autofix === 'pad' && this.value.length + 1 < this.maxLength) {\n        return super._appendCharRaw(fromStr[this.value.length], flags).aggregate(this._appendCharRaw(ch, flags));\n      }\n      return super._appendCharRaw(toStr[this.value.length], flags);\n    }\n    return super._appendCharRaw(ch, flags);\n  }\n  doValidate(flags) {\n    const str = this.value;\n    const firstNonZero = str.search(/[^0]/);\n    if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\n    const [minstr, maxstr] = this.boundaries(str);\n    return this.from <= Number(maxstr) && Number(minstr) <= this.to && super.doValidate(flags);\n  }\n  pad(flags) {\n    const details = new ChangeDetails();\n    if (this.value.length === this.maxLength) return details;\n    const value = this.value;\n    const padLength = this.maxLength - this.value.length;\n    if (padLength) {\n      this.reset();\n      for (let i = 0; i < padLength; ++i) {\n        details.aggregate(super._appendCharRaw('0', flags));\n      }\n\n      // append tail\n      value.split('').forEach(ch => this._appendCharRaw(ch));\n    }\n    return details;\n  }\n}\nIMask.MaskedRange = MaskedRange;\n\nexport { MaskedRange as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}