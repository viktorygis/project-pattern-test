{"ast":null,"code":"import MaskedPattern from './pattern.js';\nimport IMask from '../core/holder.js';\nimport ChangeDetails from '../core/change-details.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport './base.js';\nimport './factory.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/input-definition.js';\nimport './regexp.js';\n\n/** Pattern which validates enum values */\nclass MaskedEnum extends MaskedPattern {\n  constructor(opts) {\n    super({\n      ...MaskedEnum.DEFAULTS,\n      ...opts\n    }); // mask will be created in _update\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    const {\n      enum: enum_,\n      ...eopts\n    } = opts;\n    if (enum_) {\n      const lengths = enum_.map(e => e.length);\n      const requiredLength = Math.min(...lengths);\n      const optionalLength = Math.max(...lengths) - requiredLength;\n      eopts.mask = '*'.repeat(requiredLength);\n      if (optionalLength) eopts.mask += '[' + '*'.repeat(optionalLength) + ']';\n      this.enum = enum_;\n    }\n    super._update(eopts);\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const matchFrom = Math.min(this.nearestInputPos(0, DIRECTION.FORCE_RIGHT), this.value.length);\n    const matches = this.enum.filter(e => this.matchValue(e, this.unmaskedValue + ch, matchFrom));\n    if (matches.length) {\n      if (matches.length === 1) {\n        this._forEachBlocksInRange(0, this.value.length, (b, bi) => {\n          const mch = matches[0][bi];\n          if (bi >= this.value.length || mch === b.value) return;\n          b.reset();\n          b._appendChar(mch, flags);\n        });\n      }\n      const d = super._appendCharRaw(matches[0][this.value.length], flags);\n      if (matches.length === 1) {\n        matches[0].slice(this.unmaskedValue.length).split('').forEach(mch => d.aggregate(super._appendCharRaw(mch)));\n      }\n      return d;\n    }\n    return new ChangeDetails({\n      skip: !this.isComplete\n    });\n  }\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    // just drop tail\n    return new ContinuousTailDetails('', fromPos);\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    if (fromPos === toPos) return new ChangeDetails();\n    const matchFrom = Math.min(super.nearestInputPos(0, DIRECTION.FORCE_RIGHT), this.value.length);\n    let pos;\n    for (pos = fromPos; pos >= 0; --pos) {\n      const matches = this.enum.filter(e => this.matchValue(e, this.value.slice(matchFrom, pos), matchFrom));\n      if (matches.length > 1) break;\n    }\n    const details = super.remove(pos, toPos);\n    details.tailShift += pos - fromPos;\n    return details;\n  }\n  get isComplete() {\n    return this.enum.indexOf(this.value) >= 0;\n  }\n}\n/** Match enum value */\nMaskedEnum.DEFAULTS = {\n  ...MaskedPattern.DEFAULTS,\n  matchValue: (estr, istr, matchFrom) => estr.indexOf(istr, matchFrom) === matchFrom\n};\nIMask.MaskedEnum = MaskedEnum;\nexport { MaskedEnum as default };","map":{"version":3,"names":["MaskedPattern","IMask","ChangeDetails","DIRECTION","ContinuousTailDetails","MaskedEnum","constructor","opts","DEFAULTS","updateOptions","_update","enum","enum_","eopts","lengths","map","e","length","requiredLength","Math","min","optionalLength","max","mask","repeat","_appendCharRaw","ch","flags","matchFrom","nearestInputPos","FORCE_RIGHT","value","matches","filter","matchValue","unmaskedValue","_forEachBlocksInRange","b","bi","mch","reset","_appendChar","d","slice","split","forEach","aggregate","skip","isComplete","extractTail","fromPos","toPos","displayValue","remove","pos","details","tailShift","indexOf","estr","istr","default"],"sources":["F:/web/ЗАКАЗЫ/АЙФОРДЖИ/project-pattern-test/project-root/frontend/node_modules/imask/esm/masked/enum.js"],"sourcesContent":["import MaskedPattern from './pattern.js';\nimport IMask from '../core/holder.js';\nimport ChangeDetails from '../core/change-details.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ContinuousTailDetails from '../core/continuous-tail-details.js';\nimport './base.js';\nimport './factory.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/input-definition.js';\nimport './regexp.js';\n\n/** Pattern which validates enum values */\nclass MaskedEnum extends MaskedPattern {\n  constructor(opts) {\n    super({\n      ...MaskedEnum.DEFAULTS,\n      ...opts\n    }); // mask will be created in _update\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    const {\n      enum: enum_,\n      ...eopts\n    } = opts;\n    if (enum_) {\n      const lengths = enum_.map(e => e.length);\n      const requiredLength = Math.min(...lengths);\n      const optionalLength = Math.max(...lengths) - requiredLength;\n      eopts.mask = '*'.repeat(requiredLength);\n      if (optionalLength) eopts.mask += '[' + '*'.repeat(optionalLength) + ']';\n      this.enum = enum_;\n    }\n    super._update(eopts);\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const matchFrom = Math.min(this.nearestInputPos(0, DIRECTION.FORCE_RIGHT), this.value.length);\n    const matches = this.enum.filter(e => this.matchValue(e, this.unmaskedValue + ch, matchFrom));\n    if (matches.length) {\n      if (matches.length === 1) {\n        this._forEachBlocksInRange(0, this.value.length, (b, bi) => {\n          const mch = matches[0][bi];\n          if (bi >= this.value.length || mch === b.value) return;\n          b.reset();\n          b._appendChar(mch, flags);\n        });\n      }\n      const d = super._appendCharRaw(matches[0][this.value.length], flags);\n      if (matches.length === 1) {\n        matches[0].slice(this.unmaskedValue.length).split('').forEach(mch => d.aggregate(super._appendCharRaw(mch)));\n      }\n      return d;\n    }\n    return new ChangeDetails({\n      skip: !this.isComplete\n    });\n  }\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    // just drop tail\n    return new ContinuousTailDetails('', fromPos);\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    if (fromPos === toPos) return new ChangeDetails();\n    const matchFrom = Math.min(super.nearestInputPos(0, DIRECTION.FORCE_RIGHT), this.value.length);\n    let pos;\n    for (pos = fromPos; pos >= 0; --pos) {\n      const matches = this.enum.filter(e => this.matchValue(e, this.value.slice(matchFrom, pos), matchFrom));\n      if (matches.length > 1) break;\n    }\n    const details = super.remove(pos, toPos);\n    details.tailShift += pos - fromPos;\n    return details;\n  }\n  get isComplete() {\n    return this.enum.indexOf(this.value) >= 0;\n  }\n}\n/** Match enum value */\nMaskedEnum.DEFAULTS = {\n  ...MaskedPattern.DEFAULTS,\n  matchValue: (estr, istr, matchFrom) => estr.indexOf(istr, matchFrom) === matchFrom\n};\nIMask.MaskedEnum = MaskedEnum;\n\nexport { MaskedEnum as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}