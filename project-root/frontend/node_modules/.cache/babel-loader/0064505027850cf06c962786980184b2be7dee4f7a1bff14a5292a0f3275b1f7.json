{"ast":null,"code":"import { DIRECTION, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\n/** Dynamic mask for choosing appropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  constructor(opts) {\n    super({\n      ...MaskedDynamic.DEFAULTS,\n      ...opts\n    });\n    this.currentMask = undefined;\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      this.exposeMask = undefined;\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => {\n        const {\n          expose,\n          ...maskOpts\n        } = normalizeOpts(m);\n        const masked = createMask({\n          overwrite: this._overwrite,\n          eager: this._eager,\n          skipInvalid: this._skipInvalid,\n          ...maskOpts\n        });\n        if (expose) this.exposeMask = masked;\n        return masked;\n      }) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch(appended, flags, tail) {\n    if (appended === void 0) {\n      appended = '';\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask == null ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, {\n      ...flags\n    }, tail);\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = this.currentMask.value.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else if (prevMaskState) {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n  _appendEager() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return {\n      ...flags,\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    };\n  }\n  doDispatch(appended, flags, tail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    return this.dispatch(appended, this, flags, tail);\n  }\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepare(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepare(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepareChar(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepareChar(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) == null || _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n  get value() {\n    return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    if (this.exposeMask) {\n      this.exposeMask.value = value;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n    } else super.value = value;\n  }\n  get unmaskedValue() {\n    return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    if (this.exposeMask) {\n      this.exposeMask.unmaskedValue = unmaskedValue;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n    } else super.unmaskedValue = unmaskedValue;\n  }\n  get typedValue() {\n    return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : '';\n  }\n  set typedValue(typedValue) {\n    if (this.exposeMask) {\n      this.exposeMask.typedValue = typedValue;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n      return;\n    }\n    let unmaskedValue = String(typedValue);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = typedValue;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) == null ? void 0 : _this$currentMask2.isComplete);\n  }\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) == null ? void 0 : _this$currentMask3.isFilled);\n  }\n  remove(fromPos, toPos) {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(fromPos, toPos))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n  get state() {\n    var _this$currentMask4;\n    return {\n      ...super.state,\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) == null ? void 0 : _this$currentMask4.state\n    };\n  }\n  set state(state) {\n    const {\n      compiledMasks,\n      currentMaskRef,\n      currentMask,\n      ...maskedState\n    } = state;\n    if (compiledMasks) this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n  extractInput(fromPos, toPos, flags) {\n    return this.currentMask ? this.currentMask.extractInput(fromPos, toPos, flags) : '';\n  }\n  extractTail(fromPos, toPos) {\n    return this.currentMask ? this.currentMask.extractTail(fromPos, toPos) : super.extractTail(fromPos, toPos);\n  }\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n  nearestInputPos(cursorPos, direction) {\n    return this.currentMask ? this.currentMask.nearestInputPos(cursorPos, direction) : super.nearestInputPos(cursorPos, direction);\n  }\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : this._overwrite;\n  }\n  set overwrite(overwrite) {\n    this._overwrite = overwrite;\n  }\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : this._eager;\n  }\n  set eager(eager) {\n    this._eager = eager;\n  }\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    this._skipInvalid = skipInvalid;\n  }\n  get autofix() {\n    return this.currentMask ? this.currentMask.autofix : this._autofix;\n  }\n  set autofix(autofix) {\n    this._autofix = autofix;\n  }\n  maskEquals(mask) {\n    return Array.isArray(mask) ? this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const {\n        mask: oldMask,\n        ...restOpts\n      } = mask[mi];\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    }) : super.maskEquals(mask);\n  }\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) == null ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\n/** Currently chosen mask */\n/** Currently chosen mask */\n/** Compliled {@link Masked} options */\n/** Chooses {@link Masked} depending on input value */\nMaskedDynamic.DEFAULTS = {\n  ...Masked.DEFAULTS,\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.displayValue.length : m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT);\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT)))\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\nexport { MaskedDynamic as default };","map":{"version":3,"names":["DIRECTION","objectIncludes","ChangeDetails","createMask","normalizeOpts","Masked","IMask","MaskedDynamic","constructor","opts","DEFAULTS","currentMask","undefined","updateOptions","_update","exposeMask","compiledMasks","Array","isArray","mask","map","m","expose","maskOpts","masked","overwrite","_overwrite","eager","_eager","skipInvalid","_skipInvalid","_appendCharRaw","ch","flags","details","_applyDispatch","aggregate","_appendChar","currentMaskFlags","appended","tail","prevValueBeforeTail","_beforeTailState","_value","value","inputValue","rawInputValue","insertValue","_rawInputValue","tailValue","slice","length","prevMask","prevMaskState","state","doDispatch","reset","append","raw","tailShift","_appendPlaceholder","_appendEager","appendTail","_flags$_beforeTailSta","_flags$_beforeTailSta2","currentMaskRef","dispatch","doValidate","doPrepare","str","s","currentDetails","doPrepareChar","_this$currentMask","forEach","unmaskedValue","typedValue","String","displayValue","isComplete","_this$currentMask2","Boolean","isFilled","_this$currentMask3","remove","fromPos","toPos","_this$currentMask4","maskedState","mi","extractInput","extractTail","doCommit","nearestInputPos","cursorPos","direction","autofix","_autofix","maskEquals","every","oldMask","restOpts","typedValueEquals","_this$currentMask5","inputs","index","isCurrent","startInputPos","FORCE_LEFT","weight","totalInputPositions","Math","max","sort","i1","i2","default"],"sources":["F:/web/ЗАКАЗЫ/АЙФОРДЖИ/project-pattern-test/project-root/frontend/node_modules/imask/esm/masked/dynamic.js"],"sourcesContent":["import { DIRECTION, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\n/** Dynamic mask for choosing appropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  constructor(opts) {\n    super({\n      ...MaskedDynamic.DEFAULTS,\n      ...opts\n    });\n    this.currentMask = undefined;\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      this.exposeMask = undefined;\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => {\n        const {\n          expose,\n          ...maskOpts\n        } = normalizeOpts(m);\n        const masked = createMask({\n          overwrite: this._overwrite,\n          eager: this._eager,\n          skipInvalid: this._skipInvalid,\n          ...maskOpts\n        });\n        if (expose) this.exposeMask = masked;\n        return masked;\n      }) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch(appended, flags, tail) {\n    if (appended === void 0) {\n      appended = '';\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask == null ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, {\n      ...flags\n    }, tail);\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = this.currentMask.value.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else if (prevMaskState) {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n  _appendEager() {\n    const details = this._applyDispatch();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return {\n      ...flags,\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    };\n  }\n  doDispatch(appended, flags, tail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (tail === void 0) {\n      tail = '';\n    }\n    return this.dispatch(appended, this, flags, tail);\n  }\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n  doPrepare(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepare(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepare(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  doPrepareChar(str, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    let [s, details] = super.doPrepareChar(str, flags);\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = super.doPrepareChar(s, this.currentMaskFlags(flags));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) == null || _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n  get value() {\n    return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    if (this.exposeMask) {\n      this.exposeMask.value = value;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n    } else super.value = value;\n  }\n  get unmaskedValue() {\n    return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    if (this.exposeMask) {\n      this.exposeMask.unmaskedValue = unmaskedValue;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n    } else super.unmaskedValue = unmaskedValue;\n  }\n  get typedValue() {\n    return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : '';\n  }\n  set typedValue(typedValue) {\n    if (this.exposeMask) {\n      this.exposeMask.typedValue = typedValue;\n      this.currentMask = this.exposeMask;\n      this._applyDispatch();\n      return;\n    }\n    let unmaskedValue = String(typedValue);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = typedValue;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) == null ? void 0 : _this$currentMask2.isComplete);\n  }\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) == null ? void 0 : _this$currentMask3.isFilled);\n  }\n  remove(fromPos, toPos) {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(fromPos, toPos))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n  get state() {\n    var _this$currentMask4;\n    return {\n      ...super.state,\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) == null ? void 0 : _this$currentMask4.state\n    };\n  }\n  set state(state) {\n    const {\n      compiledMasks,\n      currentMaskRef,\n      currentMask,\n      ...maskedState\n    } = state;\n    if (compiledMasks) this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n  extractInput(fromPos, toPos, flags) {\n    return this.currentMask ? this.currentMask.extractInput(fromPos, toPos, flags) : '';\n  }\n  extractTail(fromPos, toPos) {\n    return this.currentMask ? this.currentMask.extractTail(fromPos, toPos) : super.extractTail(fromPos, toPos);\n  }\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n  nearestInputPos(cursorPos, direction) {\n    return this.currentMask ? this.currentMask.nearestInputPos(cursorPos, direction) : super.nearestInputPos(cursorPos, direction);\n  }\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : this._overwrite;\n  }\n  set overwrite(overwrite) {\n    this._overwrite = overwrite;\n  }\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : this._eager;\n  }\n  set eager(eager) {\n    this._eager = eager;\n  }\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    this._skipInvalid = skipInvalid;\n  }\n  get autofix() {\n    return this.currentMask ? this.currentMask.autofix : this._autofix;\n  }\n  set autofix(autofix) {\n    this._autofix = autofix;\n  }\n  maskEquals(mask) {\n    return Array.isArray(mask) ? this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const {\n        mask: oldMask,\n        ...restOpts\n      } = mask[mi];\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    }) : super.maskEquals(mask);\n  }\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) == null ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\n/** Currently chosen mask */\n/** Currently chosen mask */\n/** Compliled {@link Masked} options */\n/** Chooses {@link Masked} depending on input value */\nMaskedDynamic.DEFAULTS = {\n  ...Masked.DEFAULTS,\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.displayValue.length : m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT);\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT)))\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\n\nexport { MaskedDynamic as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}