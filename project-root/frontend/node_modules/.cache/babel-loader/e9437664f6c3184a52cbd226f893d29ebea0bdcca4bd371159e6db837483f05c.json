{"ast":null,"code":"import ChangeDetails from '../core/change-details.js';\nimport IMask from '../core/holder.js';\nimport { DIRECTION } from '../core/utils.js';\nimport Masked from './base.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport PatternInputDefinition from './pattern/input-definition.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\n/** Pattern mask */\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  constructor(opts) {\n    super({\n      ...MaskedPattern.DEFAULTS,\n      ...opts,\n      definitions: Object.assign({}, PatternInputDefinition.DEFAULT_DEFINITIONS, opts == null ? void 0 : opts.definitions)\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this.exposeBlock = undefined;\n    this._stops = [];\n    this._maskedBlocks = {};\n    const pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          const {\n            expose,\n            repeat,\n            ...bOpts\n          } = normalizeOpts(this.blocks[bName]); // TODO type Opts<Arg & Extra>\n          const blockOpts = {\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite,\n            autofix: this.autofix,\n            ...bOpts,\n            repeat,\n            parent: this\n          };\n          const maskedBlock = repeat != null ? new IMask.RepeatBlock(blockOpts /* TODO */) : createMask(blockOpts);\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n            if (expose) this.exposeBlock = maskedBlock;\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = char in defs;\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const def = isInput ? new PatternInputDefinition({\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar,\n        ...normalizeOpts(defs[char]),\n        parent: this\n      }) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n  get state() {\n    return {\n      ...super.state,\n      _blocks: this._blocks.map(b => b.state)\n    };\n  }\n  set state(state) {\n    if (!state) {\n      this.reset();\n      return;\n    }\n    const {\n      _blocks,\n      ...maskedState\n    } = state;\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n  get isComplete() {\n    return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every(b => b.isComplete);\n  }\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n  get unmaskedValue() {\n    return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.unmaskedValue = unmaskedValue;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.unmaskedValue = unmaskedValue;\n  }\n  get value() {\n    return this.exposeBlock ? this.exposeBlock.value :\n    // TODO return _value when not in change?\n    this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.value = value;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.value = value;\n  }\n  get typedValue() {\n    return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;\n  }\n  set typedValue(value) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.typedValue = value;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.typedValue = value;\n  }\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const blockIter = this._mapPosToBlock(this.displayValue.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index, block; block = this._blocks[bi]; ++bi) {\n      var _flags$_beforeTailSta;\n      const blockDetails = block._appendChar(ch, {\n        ...flags,\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null || (_flags$_beforeTailSta = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta[bi]\n      });\n      details.aggregate(blockDetails);\n      if (blockDetails.consumed) break; // go next char\n    }\n    return details;\n  }\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.displayValue.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        var _blocks2;\n        details.aggregate(b._appendPlaceholder((_blocks2 = b._blocks) == null ? void 0 : _blocks2.length));\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.displayValue;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.displayValue.length, 0);\n  }\n  _forEachBlocksInRange(fromPos, toPos, fn) {\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].displayValue.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].displayValue.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n  nearestInputPos(cursorPos, direction) {\n    if (direction === void 0) {\n      direction = DIRECTION.NONE;\n    }\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.displayValue.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.displayValue.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    let total = 0;\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n    return total;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n  pad(flags) {\n    const details = new ChangeDetails();\n    this._forEachBlocksInRange(0, this.displayValue.length, b => details.aggregate(b.pad(flags)));\n    return details;\n  }\n}\nMaskedPattern.DEFAULTS = {\n  ...Masked.DEFAULTS,\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\nexport { MaskedPattern as default };","map":{"version":3,"names":["ChangeDetails","IMask","DIRECTION","Masked","createMask","normalizeOpts","ChunksTailDetails","PatternCursor","PatternFixedDefinition","PatternInputDefinition","MaskedPattern","constructor","opts","DEFAULTS","definitions","Object","assign","DEFAULT_DEFINITIONS","updateOptions","_update","_rebuildMask","defs","_blocks","exposeBlock","undefined","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","i","length","blocks","p","slice","bNames","keys","filter","bName","indexOf","sort","a","b","expose","repeat","bOpts","blockOpts","lazy","eager","placeholderChar","displayChar","overwrite","autofix","parent","maskedBlock","RepeatBlock","push","char","isInput","STOP_CHAR","ESCAPE_CHAR","def","isOptional","isUnmasking","state","map","reset","maskedState","forEach","bi","isComplete","every","isFilled","isFixed","doCommit","unmaskedValue","reduce","str","tail","extractTail","_blockStartPos","displayValue","appendTail","value","typedValue","aggregate","_appendPlaceholder","_appendEager","_this$_mapPosToBlock","details","startBlockIndex","_mapPosToBlock","index","d","inserted","_appendCharRaw","ch","flags","blockIter","block","_flags$_beforeTailSta","blockDetails","_appendChar","_beforeTailState","consumed","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","blockIndex","extend","extractInput","input","_","stopBefore","si","toBlockIndex","startBlockIter","endBlockIndex","_blocks2","pos","accVal","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","cursor","pushRightBeforeInput","popState","pushLeftBeforeInput","LEFT","FORCE_LEFT","pushRightBeforeFilled","ok","pushLeftBeforeRequired","pushLeftBeforeFilled","pushRightBeforeRequired","RIGHT","FORCE_RIGHT","totalInputPositions","total","name","maskedBlocks","indices","gi","pad","InputDefinition","FixedDefinition","default"],"sources":["F:/web/ЗАКАЗЫ/АЙФОРДЖИ/project-pattern-test/project-root/frontend/node_modules/imask/esm/masked/pattern.js"],"sourcesContent":["import ChangeDetails from '../core/change-details.js';\nimport IMask from '../core/holder.js';\nimport { DIRECTION } from '../core/utils.js';\nimport Masked from './base.js';\nimport createMask, { normalizeOpts } from './factory.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport PatternInputDefinition from './pattern/input-definition.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\n/** Pattern mask */\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  constructor(opts) {\n    super({\n      ...MaskedPattern.DEFAULTS,\n      ...opts,\n      definitions: Object.assign({}, PatternInputDefinition.DEFAULT_DEFINITIONS, opts == null ? void 0 : opts.definitions)\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this.exposeBlock = undefined;\n    this._stops = [];\n    this._maskedBlocks = {};\n    const pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          const {\n            expose,\n            repeat,\n            ...bOpts\n          } = normalizeOpts(this.blocks[bName]); // TODO type Opts<Arg & Extra>\n          const blockOpts = {\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite,\n            autofix: this.autofix,\n            ...bOpts,\n            repeat,\n            parent: this\n          };\n          const maskedBlock = repeat != null ? new IMask.RepeatBlock(blockOpts /* TODO */) : createMask(blockOpts);\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n            if (expose) this.exposeBlock = maskedBlock;\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const def = isInput ? new PatternInputDefinition({\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar,\n        ...normalizeOpts(defs[char]),\n        parent: this\n      }) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n  get state() {\n    return {\n      ...super.state,\n      _blocks: this._blocks.map(b => b.state)\n    };\n  }\n  set state(state) {\n    if (!state) {\n      this.reset();\n      return;\n    }\n    const {\n      _blocks,\n      ...maskedState\n    } = state;\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n  get isComplete() {\n    return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every(b => b.isComplete);\n  }\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n  get unmaskedValue() {\n    return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.unmaskedValue = unmaskedValue;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.unmaskedValue = unmaskedValue;\n  }\n  get value() {\n    return this.exposeBlock ? this.exposeBlock.value :\n    // TODO return _value when not in change?\n    this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.value = value;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.value = value;\n  }\n  get typedValue() {\n    return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;\n  }\n  set typedValue(value) {\n    if (this.exposeBlock) {\n      const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);\n      this.exposeBlock.typedValue = value;\n      this.appendTail(tail);\n      this.doCommit();\n    } else super.typedValue = value;\n  }\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const blockIter = this._mapPosToBlock(this.displayValue.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index, block; block = this._blocks[bi]; ++bi) {\n      var _flags$_beforeTailSta;\n      const blockDetails = block._appendChar(ch, {\n        ...flags,\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null || (_flags$_beforeTailSta = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta[bi]\n      });\n      details.aggregate(blockDetails);\n      if (blockDetails.consumed) break; // go next char\n    }\n    return details;\n  }\n  extractTail(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    if (flags === void 0) {\n      flags = {};\n    }\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.displayValue.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        var _blocks2;\n        details.aggregate(b._appendPlaceholder((_blocks2 = b._blocks) == null ? void 0 : _blocks2.length));\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.displayValue;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.displayValue.length, 0);\n  }\n  _forEachBlocksInRange(fromPos, toPos, fn) {\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].displayValue.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].displayValue.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n  nearestInputPos(cursorPos, direction) {\n    if (direction === void 0) {\n      direction = DIRECTION.NONE;\n    }\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.displayValue.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.displayValue.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n  totalInputPositions(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    let total = 0;\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n    return total;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n  pad(flags) {\n    const details = new ChangeDetails();\n    this._forEachBlocksInRange(0, this.displayValue.length, b => details.aggregate(b.pad(flags)));\n    return details;\n  }\n}\nMaskedPattern.DEFAULTS = {\n  ...Masked.DEFAULTS,\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\n\nexport { MaskedPattern as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}