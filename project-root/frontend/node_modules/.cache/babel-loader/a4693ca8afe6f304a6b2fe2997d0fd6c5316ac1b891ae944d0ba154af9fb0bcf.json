{"ast":null,"code":"import { escapeRegExp, DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\nvar _MaskedNumber;\n/** Number mask */\nclass MaskedNumber extends Masked {\n  /** Single char */\n\n  /** Single char */\n\n  /** Array of single chars */\n\n  /** */\n\n  /** */\n\n  /** Digits after point */\n\n  /** Flag to remove leading and trailing zeros in the end of editing */\n\n  /** Flag to pad trailing zeros after point in the end of editing */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  /** Format typed value to string */\n\n  /** Parse string to get typed value */\n\n  constructor(opts) {\n    super({\n      ...MaskedNumber.DEFAULTS,\n      ...opts\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    super._update(opts);\n    this._updateRegExps();\n  }\n  _updateRegExps() {\n    const start = '^' + (this.allowNegative ? '[+|\\\\-]?' : '');\n    const mid = '\\\\d*';\n    const end = (this.scale ? \"(\" + escapeRegExp(this.radix) + \"\\\\d{0,\" + this.scale + \"})?\" : '') + '$';\n    this._numberRegExp = new RegExp(start + mid + end);\n    this._mapToRadixRegExp = new RegExp(\"[\" + this.mapToRadix.map(escapeRegExp).join('') + \"]\", 'g');\n    this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');\n  }\n  _removeThousandsSeparators(value) {\n    return value.replace(this._thousandsSeparatorRegExp, '');\n  }\n  _insertThousandsSeparators(value) {\n    // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n    const parts = value.split(this.radix);\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\n    return parts.join(this.radix);\n  }\n  doPrepareChar(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const [prepCh, details] = super.doPrepareChar(this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (\n    /*\n      radix should be mapped when\n      1) input is done from keyboard = flags.input && flags.raw\n      2) unmasked value is set = !flags.input && !flags.raw\n      and should not be mapped when\n      1) value is set = flags.input && !flags.raw\n      2) raw value is set = !flags.input && flags.raw\n    */\n    flags.input && flags.raw || !flags.input && !flags.raw) ? ch.replace(this._mapToRadixRegExp, this.radix) : ch), flags);\n    if (ch && !prepCh) details.skip = true;\n    if (prepCh && !this.allowPositive && !this.value && prepCh !== '-') details.aggregate(this._appendChar('-'));\n    return [prepCh, details];\n  }\n  _separatorsCount(to, extendOnSeparators) {\n    if (extendOnSeparators === void 0) {\n      extendOnSeparators = false;\n    }\n    let count = 0;\n    for (let pos = 0; pos < to; ++pos) {\n      if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {\n        ++count;\n        if (extendOnSeparators) to += this.thousandsSeparator.length;\n      }\n    }\n    return count;\n  }\n  _separatorsCountFromSlice(slice) {\n    if (slice === void 0) {\n      slice = this._value;\n    }\n    return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);\n  }\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    return this._removeThousandsSeparators(super.extractInput(fromPos, toPos, flags));\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);\n    this._value = this._removeThousandsSeparators(this.value);\n    const oldValue = this._value;\n    this._value += ch;\n    const num = this.number;\n    let accepted = !isNaN(num);\n    let skip = false;\n    if (accepted) {\n      let fixedNum;\n      if (this.min != null && this.min < 0 && this.number < this.min) fixedNum = this.min;\n      if (this.max != null && this.max > 0 && this.number > this.max) fixedNum = this.max;\n      if (fixedNum != null) {\n        if (this.autofix) {\n          this._value = this.format(fixedNum, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\n          skip || (skip = oldValue === this._value && !flags.tail); // if not changed on tail it's still ok to proceed\n        } else {\n          accepted = false;\n        }\n      }\n      accepted && (accepted = Boolean(this._value.match(this._numberRegExp)));\n    }\n    let appendDetails;\n    if (!accepted) {\n      this._value = oldValue;\n      appendDetails = new ChangeDetails();\n    } else {\n      appendDetails = new ChangeDetails({\n        inserted: this._value.slice(oldValue.length),\n        rawInserted: skip ? '' : ch,\n        skip\n      });\n    }\n    this._value = this._insertThousandsSeparators(this._value);\n    const beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);\n    appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;\n    return appendDetails;\n  }\n  _findSeparatorAround(pos) {\n    if (this.thousandsSeparator) {\n      const searchFrom = pos - this.thousandsSeparator.length + 1;\n      const separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);\n      if (separatorPos <= pos) return separatorPos;\n    }\n    return -1;\n  }\n  _adjustRangeWithSeparators(from, to) {\n    const separatorAroundFromPos = this._findSeparatorAround(from);\n    if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;\n    const separatorAroundToPos = this._findSeparatorAround(to);\n    if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;\n    return [from, to];\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    const valueBeforePos = this.value.slice(0, fromPos);\n    const valueAfterPos = this.value.slice(toPos);\n    const prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);\n    this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);\n    return new ChangeDetails({\n      tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length\n    });\n  }\n  nearestInputPos(cursorPos, direction) {\n    if (!this.thousandsSeparator) return cursorPos;\n    switch (direction) {\n      case DIRECTION.NONE:\n      case DIRECTION.LEFT:\n      case DIRECTION.FORCE_LEFT:\n        {\n          const separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);\n          if (separatorAtLeftPos >= 0) {\n            const separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;\n            if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {\n              return separatorAtLeftPos;\n            }\n          }\n          break;\n        }\n      case DIRECTION.RIGHT:\n      case DIRECTION.FORCE_RIGHT:\n        {\n          const separatorAtRightPos = this._findSeparatorAround(cursorPos);\n          if (separatorAtRightPos >= 0) {\n            return separatorAtRightPos + this.thousandsSeparator.length;\n          }\n        }\n    }\n    return cursorPos;\n  }\n  doCommit() {\n    if (this.value) {\n      const number = this.number;\n      let validnum = number;\n\n      // check bounds\n      if (this.min != null) validnum = Math.max(validnum, this.min);\n      if (this.max != null) validnum = Math.min(validnum, this.max);\n      if (validnum !== number) this.unmaskedValue = this.format(validnum, this);\n      let formatted = this.value;\n      if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\n      if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);\n      this._value = formatted;\n    }\n    super.doCommit();\n  }\n  _normalizeZeros(value) {\n    const parts = this._removeThousandsSeparators(value).split(this.radix);\n\n    // remove leading zeros\n    parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, (match, sign, zeros, num) => sign + num);\n    // add leading zero\n    if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + '0';\n    if (parts.length > 1) {\n      parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros\n      if (!parts[1].length) parts.length = 1; // remove fractional\n    }\n    return this._insertThousandsSeparators(parts.join(this.radix));\n  }\n  _padFractionalZeros(value) {\n    if (!value) return value;\n    const parts = value.split(this.radix);\n    if (parts.length < 2) parts.push('');\n    parts[1] = parts[1].padEnd(this.scale, '0');\n    return parts.join(this.radix);\n  }\n  doSkipInvalid(ch, flags, checkTail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const dropFractional = this.scale === 0 && ch !== this.thousandsSeparator && (ch === this.radix || ch === MaskedNumber.UNMASKED_RADIX || this.mapToRadix.includes(ch));\n    return super.doSkipInvalid(ch, flags, checkTail) && !dropFractional;\n  }\n  get unmaskedValue() {\n    return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, MaskedNumber.UNMASKED_RADIX);\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  get typedValue() {\n    return this.parse(this.unmaskedValue, this);\n  }\n  set typedValue(n) {\n    this.rawInputValue = this.format(n, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\n  }\n\n  /** Parsed Number */\n  get number() {\n    return this.typedValue;\n  }\n  set number(number) {\n    this.typedValue = number;\n  }\n  get allowNegative() {\n    return this.min != null && this.min < 0 || this.max != null && this.max < 0;\n  }\n  get allowPositive() {\n    return this.min != null && this.min > 0 || this.max != null && this.max > 0;\n  }\n  typedValueEquals(value) {\n    // handle  0 -> '' case (typed = 0 even if value = '')\n    // for details see https://github.com/uNmAnNeR/imaskjs/issues/134\n    return (super.typedValueEquals(value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === '');\n  }\n}\n_MaskedNumber = MaskedNumber;\nMaskedNumber.UNMASKED_RADIX = '.';\nMaskedNumber.EMPTY_VALUES = [...Masked.EMPTY_VALUES, 0];\nMaskedNumber.DEFAULTS = {\n  ...Masked.DEFAULTS,\n  mask: Number,\n  radix: ',',\n  thousandsSeparator: '',\n  mapToRadix: [_MaskedNumber.UNMASKED_RADIX],\n  min: Number.MIN_SAFE_INTEGER,\n  max: Number.MAX_SAFE_INTEGER,\n  scale: 2,\n  normalizeZeros: true,\n  padFractionalZeros: false,\n  parse: Number,\n  format: n => n.toLocaleString('en-US', {\n    useGrouping: false,\n    maximumFractionDigits: 20\n  })\n};\nIMask.MaskedNumber = MaskedNumber;\nexport { MaskedNumber as default };","map":{"version":3,"names":["escapeRegExp","DIRECTION","ChangeDetails","Masked","IMask","_MaskedNumber","MaskedNumber","constructor","opts","DEFAULTS","updateOptions","_update","_updateRegExps","start","allowNegative","mid","end","scale","radix","_numberRegExp","RegExp","_mapToRadixRegExp","mapToRadix","map","join","_thousandsSeparatorRegExp","thousandsSeparator","_removeThousandsSeparators","value","replace","_insertThousandsSeparators","parts","split","doPrepareChar","ch","flags","prepCh","details","length","input","raw","skip","allowPositive","aggregate","_appendChar","_separatorsCount","to","extendOnSeparators","count","pos","_value","indexOf","_separatorsCountFromSlice","slice","extractInput","fromPos","toPos","displayValue","_adjustRangeWithSeparators","_appendCharRaw","prevBeforeTailValue","tail","_beforeTailState","prevBeforeTailSeparatorsCount","oldValue","num","number","accepted","isNaN","fixedNum","min","max","autofix","format","UNMASKED_RADIX","Boolean","match","appendDetails","inserted","rawInserted","beforeTailValue","beforeTailSeparatorsCount","tailShift","_findSeparatorAround","searchFrom","separatorPos","from","separatorAroundFromPos","separatorAroundToPos","remove","valueBeforePos","valueAfterPos","nearestInputPos","cursorPos","direction","NONE","LEFT","FORCE_LEFT","separatorAtLeftPos","separatorAtLeftEndPos","RIGHT","FORCE_RIGHT","separatorAtRightPos","doCommit","validnum","Math","unmaskedValue","formatted","normalizeZeros","_normalizeZeros","padFractionalZeros","_padFractionalZeros","sign","zeros","test","push","padEnd","doSkipInvalid","checkTail","dropFractional","includes","typedValue","parse","n","rawInputValue","typedValueEquals","EMPTY_VALUES","mask","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","toLocaleString","useGrouping","maximumFractionDigits","default"],"sources":["F:/web/ЗАКАЗЫ/АЙФОРДЖИ/project-pattern-test/project-root/frontend/node_modules/imask/esm/masked/number.js"],"sourcesContent":["import { escapeRegExp, DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\nvar _MaskedNumber;\n/** Number mask */\nclass MaskedNumber extends Masked {\n  /** Single char */\n\n  /** Single char */\n\n  /** Array of single chars */\n\n  /** */\n\n  /** */\n\n  /** Digits after point */\n\n  /** Flag to remove leading and trailing zeros in the end of editing */\n\n  /** Flag to pad trailing zeros after point in the end of editing */\n\n  /** Enable characters overwriting */\n\n  /** */\n\n  /** */\n\n  /** */\n\n  /** Format typed value to string */\n\n  /** Parse string to get typed value */\n\n  constructor(opts) {\n    super({\n      ...MaskedNumber.DEFAULTS,\n      ...opts\n    });\n  }\n  updateOptions(opts) {\n    super.updateOptions(opts);\n  }\n  _update(opts) {\n    super._update(opts);\n    this._updateRegExps();\n  }\n  _updateRegExps() {\n    const start = '^' + (this.allowNegative ? '[+|\\\\-]?' : '');\n    const mid = '\\\\d*';\n    const end = (this.scale ? \"(\" + escapeRegExp(this.radix) + \"\\\\d{0,\" + this.scale + \"})?\" : '') + '$';\n    this._numberRegExp = new RegExp(start + mid + end);\n    this._mapToRadixRegExp = new RegExp(\"[\" + this.mapToRadix.map(escapeRegExp).join('') + \"]\", 'g');\n    this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');\n  }\n  _removeThousandsSeparators(value) {\n    return value.replace(this._thousandsSeparatorRegExp, '');\n  }\n  _insertThousandsSeparators(value) {\n    // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n    const parts = value.split(this.radix);\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\n    return parts.join(this.radix);\n  }\n  doPrepareChar(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const [prepCh, details] = super.doPrepareChar(this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (\n    /*\n      radix should be mapped when\n      1) input is done from keyboard = flags.input && flags.raw\n      2) unmasked value is set = !flags.input && !flags.raw\n      and should not be mapped when\n      1) value is set = flags.input && !flags.raw\n      2) raw value is set = !flags.input && flags.raw\n    */\n    flags.input && flags.raw || !flags.input && !flags.raw) ? ch.replace(this._mapToRadixRegExp, this.radix) : ch), flags);\n    if (ch && !prepCh) details.skip = true;\n    if (prepCh && !this.allowPositive && !this.value && prepCh !== '-') details.aggregate(this._appendChar('-'));\n    return [prepCh, details];\n  }\n  _separatorsCount(to, extendOnSeparators) {\n    if (extendOnSeparators === void 0) {\n      extendOnSeparators = false;\n    }\n    let count = 0;\n    for (let pos = 0; pos < to; ++pos) {\n      if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {\n        ++count;\n        if (extendOnSeparators) to += this.thousandsSeparator.length;\n      }\n    }\n    return count;\n  }\n  _separatorsCountFromSlice(slice) {\n    if (slice === void 0) {\n      slice = this._value;\n    }\n    return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);\n  }\n  extractInput(fromPos, toPos, flags) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    return this._removeThousandsSeparators(super.extractInput(fromPos, toPos, flags));\n  }\n  _appendCharRaw(ch, flags) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);\n    this._value = this._removeThousandsSeparators(this.value);\n    const oldValue = this._value;\n    this._value += ch;\n    const num = this.number;\n    let accepted = !isNaN(num);\n    let skip = false;\n    if (accepted) {\n      let fixedNum;\n      if (this.min != null && this.min < 0 && this.number < this.min) fixedNum = this.min;\n      if (this.max != null && this.max > 0 && this.number > this.max) fixedNum = this.max;\n      if (fixedNum != null) {\n        if (this.autofix) {\n          this._value = this.format(fixedNum, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\n          skip || (skip = oldValue === this._value && !flags.tail); // if not changed on tail it's still ok to proceed\n        } else {\n          accepted = false;\n        }\n      }\n      accepted && (accepted = Boolean(this._value.match(this._numberRegExp)));\n    }\n    let appendDetails;\n    if (!accepted) {\n      this._value = oldValue;\n      appendDetails = new ChangeDetails();\n    } else {\n      appendDetails = new ChangeDetails({\n        inserted: this._value.slice(oldValue.length),\n        rawInserted: skip ? '' : ch,\n        skip\n      });\n    }\n    this._value = this._insertThousandsSeparators(this._value);\n    const beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);\n    appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;\n    return appendDetails;\n  }\n  _findSeparatorAround(pos) {\n    if (this.thousandsSeparator) {\n      const searchFrom = pos - this.thousandsSeparator.length + 1;\n      const separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);\n      if (separatorPos <= pos) return separatorPos;\n    }\n    return -1;\n  }\n  _adjustRangeWithSeparators(from, to) {\n    const separatorAroundFromPos = this._findSeparatorAround(from);\n    if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;\n    const separatorAroundToPos = this._findSeparatorAround(to);\n    if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;\n    return [from, to];\n  }\n  remove(fromPos, toPos) {\n    if (fromPos === void 0) {\n      fromPos = 0;\n    }\n    if (toPos === void 0) {\n      toPos = this.displayValue.length;\n    }\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    const valueBeforePos = this.value.slice(0, fromPos);\n    const valueAfterPos = this.value.slice(toPos);\n    const prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);\n    this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);\n    return new ChangeDetails({\n      tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length\n    });\n  }\n  nearestInputPos(cursorPos, direction) {\n    if (!this.thousandsSeparator) return cursorPos;\n    switch (direction) {\n      case DIRECTION.NONE:\n      case DIRECTION.LEFT:\n      case DIRECTION.FORCE_LEFT:\n        {\n          const separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);\n          if (separatorAtLeftPos >= 0) {\n            const separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;\n            if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {\n              return separatorAtLeftPos;\n            }\n          }\n          break;\n        }\n      case DIRECTION.RIGHT:\n      case DIRECTION.FORCE_RIGHT:\n        {\n          const separatorAtRightPos = this._findSeparatorAround(cursorPos);\n          if (separatorAtRightPos >= 0) {\n            return separatorAtRightPos + this.thousandsSeparator.length;\n          }\n        }\n    }\n    return cursorPos;\n  }\n  doCommit() {\n    if (this.value) {\n      const number = this.number;\n      let validnum = number;\n\n      // check bounds\n      if (this.min != null) validnum = Math.max(validnum, this.min);\n      if (this.max != null) validnum = Math.min(validnum, this.max);\n      if (validnum !== number) this.unmaskedValue = this.format(validnum, this);\n      let formatted = this.value;\n      if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\n      if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);\n      this._value = formatted;\n    }\n    super.doCommit();\n  }\n  _normalizeZeros(value) {\n    const parts = this._removeThousandsSeparators(value).split(this.radix);\n\n    // remove leading zeros\n    parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, (match, sign, zeros, num) => sign + num);\n    // add leading zero\n    if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + '0';\n    if (parts.length > 1) {\n      parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros\n      if (!parts[1].length) parts.length = 1; // remove fractional\n    }\n    return this._insertThousandsSeparators(parts.join(this.radix));\n  }\n  _padFractionalZeros(value) {\n    if (!value) return value;\n    const parts = value.split(this.radix);\n    if (parts.length < 2) parts.push('');\n    parts[1] = parts[1].padEnd(this.scale, '0');\n    return parts.join(this.radix);\n  }\n  doSkipInvalid(ch, flags, checkTail) {\n    if (flags === void 0) {\n      flags = {};\n    }\n    const dropFractional = this.scale === 0 && ch !== this.thousandsSeparator && (ch === this.radix || ch === MaskedNumber.UNMASKED_RADIX || this.mapToRadix.includes(ch));\n    return super.doSkipInvalid(ch, flags, checkTail) && !dropFractional;\n  }\n  get unmaskedValue() {\n    return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, MaskedNumber.UNMASKED_RADIX);\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n  get typedValue() {\n    return this.parse(this.unmaskedValue, this);\n  }\n  set typedValue(n) {\n    this.rawInputValue = this.format(n, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\n  }\n\n  /** Parsed Number */\n  get number() {\n    return this.typedValue;\n  }\n  set number(number) {\n    this.typedValue = number;\n  }\n  get allowNegative() {\n    return this.min != null && this.min < 0 || this.max != null && this.max < 0;\n  }\n  get allowPositive() {\n    return this.min != null && this.min > 0 || this.max != null && this.max > 0;\n  }\n  typedValueEquals(value) {\n    // handle  0 -> '' case (typed = 0 even if value = '')\n    // for details see https://github.com/uNmAnNeR/imaskjs/issues/134\n    return (super.typedValueEquals(value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === '');\n  }\n}\n_MaskedNumber = MaskedNumber;\nMaskedNumber.UNMASKED_RADIX = '.';\nMaskedNumber.EMPTY_VALUES = [...Masked.EMPTY_VALUES, 0];\nMaskedNumber.DEFAULTS = {\n  ...Masked.DEFAULTS,\n  mask: Number,\n  radix: ',',\n  thousandsSeparator: '',\n  mapToRadix: [_MaskedNumber.UNMASKED_RADIX],\n  min: Number.MIN_SAFE_INTEGER,\n  max: Number.MAX_SAFE_INTEGER,\n  scale: 2,\n  normalizeZeros: true,\n  padFractionalZeros: false,\n  parse: Number,\n  format: n => n.toLocaleString('en-US', {\n    useGrouping: false,\n    maximumFractionDigits: 20\n  })\n};\nIMask.MaskedNumber = MaskedNumber;\n\nexport { MaskedNumber as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}